Replace all instances of 'myArr' to 'arr' and 'myArr1' to 'arr1' etc.
maybe replace JS type conversion section to a conversion table
once completed use change to markdown ctrl-shift-m


JavaScript
	programming language used for the web, server programs like Node.js and databases like MongoDB
	program behaviour of web pages
	can change HTML Content, attributes and styles(CSS)
	Requirments: none

syntax:
<script> js code </script> // internal within html
<script src="myScript.js"></script> // external - point to js file within html

Javascript can be placed within head or body of html

Output
	display data in different ways:
		innerHTML	- write into HTML element
		document.write() - write into HTML output
		window.alert() - write to alert box
		console.log() - write to browser console
	innerHTML - property that defines HTML content
		can use document.getElementById(id) to access HTML element
		changing innerHTML property of an element is a common way of displaying data
	document.write() - good for testing purposes
		warning: using document.write() after html document is lodaed will delete all existing HTML
		<h1>My First Web Page</h1>
		<p>My first paragraph.</p>
		// button pressed after html is loaded
		<button type="button" onclick="document.write(5 + 6)">Try it</button>
	Window.alert()
		window.alert(5 + 6);
	console.log() - usefull for depugging purposes
	JavaScript print - there are no print objects or print methods
		cannot access output devices from JS
		One exception is using:
		window.print() - prints current window content

JS statements
	compose of values, operators, expressions, keywords and comments
	statements are executed one by one in order from top to bottom of file
	';' seperates JS statements
	multipul stasemnts are allowed on one line
whitespace is ignored
JS is case sensitive
Hyphens are not allowed in JavaScript. They are reserved for subtractions.
best to use camelCase

// comment
/* multi-line comment */

Variables

	let variable; // same as undefined if not already initialise
	let string = "Hello";
	let num = 10;
	let float = 15.371;
	let bool = true;
	let arr = [red,green,blue];
	let dog = { name : 'Spot', breed : 'Dalmatian' };
	let notDefine = undefined;
	let nothing = null; // typeof is an object but is null
		undefined vs null
		typeof undefined    // undefined
		typeof null         // object
		null === undefined  // false
		null == undefined   // true
	// constant
	const constant = 9;

		All JS datatypes have a 'valuOf()' and 'toString()' method

	typeof - operator to find type of variable
		typeof "John" // Returns "string"
		typeof 314  // Returns "number"

	primative data - simtle single data value
		typeop operator returns these primative types
			string, number, boolian, undefined
	complex data
		typeof operator returns either:
			function
			object - returns 'object' for objects, arrays and null

	JS identifiers rule
		can contain letters, digits, underscores and dollar signs
		must start with letter or '$'
		reserved words cannot be used such as JS keywords
Function - block of code to perform a particular task
	function is executed when it is invoked
	function name(parameter1, parameter2, parameter3) {
	  // code to be executed
	}

	Local scope
		variables decalared in a function become local to it
		local variables are created when a func starts and deleted when func complete
			variables can only be accessde from within the function
			// cannot use myVar (outside of scope)

			function myFunction() {
			  let myVar = "hello";
			  // can use myVar (within scope)
			}

			// cannot use myVar (outside of scope)

Obejects
	objects have properties and methods
	properties are writen in 'name:value' pairs:
		let myObj = {shape:"square", size:"500", color:"white"};
		access object properties
			'objName.propertyName' or 'objName["propertyName"]'
	methods are actions that can be preformed on okjects
	a method is a function stored as a property:
		let person = {
		  firstName: "John",
		  lastName : "Doe",
		  id       : 5566,
		  fullName : function() {
		    return this.firstName + " " + this.lastName;
		  }
		};
		access object methods
			'objName.methodName()'
			accessing a method without '()' returns the function definition
	Avoid declaring strings, numbers and booleans as objects
		* as they complicate code and slow down execution speed
		when a var is declared with the 'new' keyword the var is created as an object
	let x = new String();        // Declares x as a String object
	let y = new Number();        // Declares y as a Number object
	let z = new Boolean();       // Declares z as a Boolean object

	comparing JS oblects will always return false (x==y) and (x===y)

	all JS obj have a toString() method

	'this' keyword
		in a function definition this refers to the owner of the functon
Events
	HTML events cause "something" to happen to HTML elements
	when JS is used in HTML, JS can "react" on these events
	JS can execute code when events are detected
	<element event='some JavaScript'> or <element event="some JavaScript">
	e.g. <button onclick="document.getElementById('demo').innerHTML = Date()">The time is?</button>
	or call a func:  <button onclick="displayDate()">The time is?</button>
	common HTML events
	onchange, onclick, onmouseover, onmouseout, onkeydown, onload
	event handlers can handle and verify, user input, user actions and browser actions

Strings
	let squote = 'single quotes';
	let dquote = "or double";
	find length of strings with the built-in 'lenght' property
		let txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		document.getElementById("demo").innerHTML = txt.length;
	escape char '\' turns special chars into string chars
String methods
	primative values vannot have properties or methods as they are not objects
	however methods and properties are available to primitive values
		as JS treats primative values as objects when execusing methods and properties
		e.g. the 'length' property returns the length of a string
	indexOf() returns the index of the first occurenct of text within a string
	JS counts positions from zero
	lastIndexOf() returns the index last occurence of text within a string (searches backwards)
	indexOf() and lastIndexOf() both:
		* return '-1' when no occurence found
		* accept second parameter for starting position for search
	search() acts exactly same as indexOf() but does not take second starting position argument, and can take powerful search values (regular expressions) which indexOf() cannot
	Extracting string parts	- three methods to extract part of sting
    slice(start, end) - returns extracted part in a new string
    substring(start, end) - same as slice() but cannot take negatives
    substr(start, length) - same as slice but second parameter species length to be extracted
    start and end values are indexes, if negative the position is counted from end of string. can have one parameter
	replacing string content
		replace('strPart','replacement') - replaces value with another (in a new sting)
			default: case sensitive, first word match
				regular expressions are written without quotes
				replace case insensitive by using a regular expression with '/i' flag (insensitive)
					replace(/strPart/i,'replacement')
				repalce all matches using a regular expression with '/g' flag (global match)
					replace(/strPart/g,'replacement')
	convert to upper and lower case
		toUpperCase() converts to upper case
		toLowerCase() converts to lower case
	concatination
		concat() joins two or more strings
	remove whitespace
		trim() removes whitespase from both sides of string
			(not supported IE8 or lower)
		for IE8 support use replace() with a regular expression:
			replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ''))
			use above solution to add trim function to 'string.prototype'
	extracting chars - three main methods
    charAt(position) - return char at specified index
    charCodeAt(position) returns unicode of char at specified index
    Property access[ ] - same as charAt() but uses property access
    	property access may beu npredictable
  convert string to array
  	split()
	  	split(",") // split on commas
			split(" ") // split on spaces
			split("|") // split on pipe
			split("")  // split on chars
Numbers
	JS has only one type of number; no int, short, long, float
	can use scientific notation for extra samll and large numbers 'let x= 12e5;'
	JS numbers are always 64-bit floating point, they are always stored as double precision floating point numbers
	this format stores numbers in64 bits, where faction the number is stored in bits 0-51, exponent in 52-62 and the sign in 63
	Precision
		ints are accurate up to 15 digits
		macimum number of decimals is 17 digits
	Adding numbers and strings
		JS use '+' for both addition and concatenation
			numbers are added
			strings are concatinated
		num + num = num
		str + str = str
		num + str = str
		str + num = str
	Numeric strings
		JS strings can have numeric content
		JS will try to convert string to numbers in all numeric operations
		"2" + "1" = "21" //str '+' concatinates
		"2" - "1" = 1    //num
		"2" * "1" = 2    //num
		"2" / "1" = 2    //num
	NaN - Not a Number
		JS reserved word indicating that a numder is not a legal number
		arithmetics with non-numeric strings result in NaN
		1 * "hello" = NaN
		1 * "100" = 100    // number with numeric stirng
		isNaN() - returns true if not a number
		isNaN is a gloval JS function
		NaN is a number 'typof NaN' //returns number
	Infinity - returned if number outride of largest possible number
		let myNumber = 2;
			while (myNumber != Infinity) {   // Execute until Infinity
			  myNumber = myNumber * myNumber;
			}
		division by zero generates 'Infinity'
		Infinity is a number 'typeof Infinity' //returns number
	Hexadecimal
		JS interprets numeric constants as hexadecimal if preceded by 0x
			let x = 0xFF // x will be 255
		defualt: JS display numbers as base 10 decimals
			but toString() output numbers form base 2 to base 36
			hecadecimal - base 16, deciaml - base 10, octal - 8, binary - 2
				var myNumber = 32;
				myNumber.toString(10);  // returns 32
				myNumber.toString(32);  // returns 10
				myNumber.toString(16);  // returns 20
				myNumber.toString(8);   // returns 40
				myNumber.toString(2);   // returns 100000
Number methods
	All number methods can be used on any type on numbers (literals, vars, or expressions)
	toString() returns a number as a string
	toExonential(charsRoundedAfterDecimal) returns string, with number rounded using exponential notation // parameter will not round number if no parameter
	toFixed(noOfDecimals) returns a string. with specified numder of decimals
	toPrecision() returns string, with specified number length
	valueOf() returns a number as a number // no reason to use in your code
	converting vars to numbers - 3 methods
		these methods are global JS method not number methods
		Number() - returns number, converted from argument
		parseInt() - returns integer, from parsing argument
		parseFloat() - returns float, from parsing argument

		Number(true);      // returns 1
		Number(false);     // returns 0
		Number("10");      // returns 10
		Number("10.33");   // returns 10.33
		Number("10 33");   // returns NaN if number cannot be converted
 		Number(new Date("2017-09-30")); // returns 1506729600000 - milisecs since 1.1.1970

 		parseFloat, parseInt - spaces are allowed, but only first num is returned:
			parseInt("10");         // returns 10
			parseInt("10.33");      // returns 10
			parseInt("10 20 30");   // returns 10
			parseInt("10 years");   // returns 10
			parseInt("years 10");   // returns NaN

			parseFloat("10");        // returns 10
			parseFloat("10.33");     // returns 10.33
			parseFloat("10 20 30");  // returns 10
			parseFloat("10 years");  // returns 10
			parseFloat("years 10");  // returns NaN
	Number properties
	MAX_VALUE - returns largest possible number in JS
	MIN_VALUE - returns smallest possible number in JS
	POSITIVLE_INFINITY - represents positive infinity (returned on overflow)
	NEGATIVE_INFINITY - represents negative infinity (returned on overflow)
	NaN - represtents not a number value
		number properties cannot be used on vars
		number properties belong to the JS number object wrapper called Number
		there properties can olny be accessed as Number.MAX_VALUE
			not var.MAX_VALUE, expression or value will return undefined
Arrays
	store multiple values in a single var
	values can be accessed using indexes
	creating array:
		array literal is easiet way to create JS array
			let array_name = [item1, item2, ...];
		Dont use: JS 'new' keyword also creates array
		let cars = new Array("Saab", "Volvo", "BMW"); // use array literal instead as simpler, faster and easily readable.
	access element of array
		myArray[0] // selects first element
	change array element
		myArray[0] = "changed";
 	access full array by reffering to array name
		document.getElementById("demo").innerHTML = myArray;
	arrays are objects
		but best described as arrays
		arrays use numbers to access its elements myArr[0]
		objects use names to access its members   myObj.firstMember
	array elements can be objects
		variables of different types can be in the same array
			objects, functions and arrays can all be within the same array
	array properties and methods
		built-in array properties and methods are very useful
		length - returns length of array (highest index + 1)
			myArr[0] 										//accessing first element
			myArr[myArr.length - 1]     //accessing last element
	loop through arrays
		// for loop - easiest
			var fruits, text, fLen, i;
			fruits = ["Banana", "Orange", "Apple", "Mango"];
			fLen = fruits.length;

			text = "<ul>";
			for (i = 0; i < fLen; i++) {
			  text += "<li>" + fruits[i] + "</li>";
			}
			text += "</ul>";
		// Array.foreach() function
			var fruits, text;
			fruits = ["Banana", "Orange", "Apple", "Mango"];

			text = "<ul>";
			fruits.forEach(myFunction);
			text += "</ul>";

			function myFunction(value) {
			  text += "<li>" + value + "</li>";
			}
	add array elments
		esiest way - push()
			var fruits = ["Banana", "Orange", "Apple", "Mango"];
			fruits.push("Lemon");    // adds a new element (Lemon) to fruits
		also 'length' property
			var fruits = ["Banana", "Orange", "Apple", "Mango"];
			fruits[fruits.length] = "Lemon";    // adds a new element (Lemon) to fruits
		adding elements with a very high index(not next index) causes undefined to fill between:
			var fruits = ["Banana", "Orange", "Apple", "Mango"];
			fruits[6] = "Lemon";    // adds a new element (Lemon) to fruits but adds undefined
	associative arrays  - named indexes
		JS does not support associative arrays
		JS arrays are always numbered
	array vs objects
		arr - numbered indexes
		obj - named indexes
		When to use arrys or Objects
			objects when want named elments
			arrays when want numbered elements
	Avoid new Array()
		no need to use new Array()
		can also complicate code (produces undefined when changing)
		use '[]' instead
	recognize array
		typeof - returns type object
		Array.isArray(myArray) returns true if array
			some browsers do not support this method
				solved: create your own isArrau() function
					function isArray(x) { // returns true if array
					  return x.constructor.toString().indexOf("Array") > -1;
					} // actually returns true if obj protopype contains word array
		instanceof operator returns true if an object is created by a given constructor
			var fruits = ["Banana", "Orange", "Apple", "Mango"];
			fruits instanceof Array;   // returns true
Array methods
	toString() - converts array to string of array values seperated by comma
		myArr.toString();
	join() - same as toString(), but can specify the seperator
		myArr.join(" - ")
	popping - removing last element
		pop() returns last element which is "popped out"
		myArr.pop()
	pushing - add element
		push() returns the new array length and adds new element
		myArr.push("newElement")
	shifting - same as popping, but removes first element
		shift() returns value that was "shifted out" and "shifts" all other indexes lower
			myArr.shift()
		unshift() returns the new array length and adds new element to beggining of array and "unshifts" older elements
	changing elements
		access array elements by using their index number
		length property is an easy way to append new elements to an array
	deleting elements
		delete operator deletes elments
			delete myArr[0]
		deleting elements replaces them with 'undefined'
			use shift() or pop() instead
	splicing array
		splice() add new items and returns an array of deleted items
			splice(indexNo, noOfElementsToRemove, newElements, newElem.., ...)
			myArr.splice(3, 0, "myNewElement1", "myNewElement2")
	splicing to remove elements
		can remove elements without leaving holes in array like 'delete'
		myArr.splice(0, 2) // removes first 2 item
	concatenating arrays
		concat() returns a new merged array, can take multiple arguments
			arr1.concat(arr2);
			arr1.concat(arr2, arr3);
		also take string arguments
			arr1.concat("hello")
	slicing array - cut out piece of array in a new array (original fine)
		slice() returns a new array without the sliced elements
		slice(start/ingIndex, endIndex) // second arg is optional
		arr.slice(2) // removes third element to end element
		arr.slice(2, 4) // removes third to fifth elements
	Automatic toString()
		JS automatically convertr an array to comma seperated string when a primative value is expected
			this always happens when you try to outpup an array
			both do same thing:
				var fruits = ["Banana", "Orange", "Apple", "Mango"];
				document.getElementById("demo").innerHTML = fruits;
				document.getElementById("demo").innerHTML = fruits.toString();
Sorting arrays
	sort() sorts array alphabetically
	reverse() reverse the elements in array, to sort reverse alphabet use 'sort' then 'reverse'
	numeric sort
		Default: sort() sorts values as strings
		A compare function can solve this problem:
			numArr.sort(function(a, b){return a - b});  // ascending
			numArr.sort(function(a, b){return b - a});  // descending
			a compare function should return a negative, zero, or positive value
				If result is negative a is sorted before b.
				If result is positive b is sorted before a.
				If result is 0 no changes are done with the sort order of the two values.
			the compare function compares all values within array two at a time (a, b)
				e.g. (30, 40) = (30 - 40) = -10 = negative = 30 is sorted before 40
	randomly sort array
		// example below favours some numbers over others
		numArr.sort(function(a, b){return 0.5 - Math.random()}); // not very random
		A popular method is the Fisher Yates shuffle, implemented in JS:
			var points = [40, 100, 1, 5, 25, 10];
			for (i = points.length -1; i > 0; i--) {
			  j = Math.floor(Math.random() * i)
			  k = points[i]
			  points[i] = points[j]
			  points[j] = k
			}
	highest/lowest values
		Max and Min values - no built-in feature
		however, after sorting using the highest and lowest index values
			but, sorting a whole array is inefficient for finding the highest/lowest value
		arr.sort(function(a, b){return a - b});   // sort ascending
		console.log arr[0];            //for lowest value
		console.log arr[arr.length-1]; //for highest value
		arr.sort(function(a, b){return b - a});  // sort descending
		console.log arr[0];            //for highest value
		console.log arr[arr.length-1]; //for lowest value
		re: but, sorting a whole array is inefficient for finding the highest/lowest value
		Math.max.apply can find highest number in array
			function myArrayMax(arr) {
			  return Math.max.apply(null, arr);
			} 			// Math.max.apply(null, [1, 2, 3]) is equivalent to Math.max(1, 2, 3)
		Math.min.apply can find lowest number in array
			function myArrayMin(arr) {
			  return Math.min.apply(null, arr);
			}       //Math.min.apply(null, [1, 2, 3]) is equivalent to Math.min(1, 2, 3)
	my min/max JS methods
		Fastest solution is to use a user made method
		function loops through an array comparing each value with the highest value found:
			function myArrayMax(arr) {
			  var len = arr.length;
			  var max = -Infinity;
			  while (len--) {
			    if (arr[len] > max) {
			      max = arr[len];
			    }
			  }
			  return max;
			}
		This function loops through an array comparing each value with the lowest value found:
			function myArrayMin(arr) {
			  var len = arr.length;
			  var min = Infinity;
			  while (len--) {
			    if (arr[len] < min) {
			      min = arr[len];
			    }
			  }
			  return min;
			}
	sorting object arrays
		arr.sort(function(a, b){return a.property - b.property});
		Comparing string properties is a little more complex:
			cars.sort(function(a, b){
			  var x = a.type.toLowerCase();
			  var y = b.type.toLowerCase();
			  if (x < y) {return -1;}
			  if (x > y) {return 1;}
			  return 0;
			});
Array iteration methods
	array iteration methods operate on every array item
	forEach() calls a function(a callback func)  (performed on each item)
		arr.forEach(myFunc)
	map() creates new array, calls a function (performed on each item)
		var numbers1 = [45, 4, 9, 16, 25];
		var numbers2 = numbers1.map(myFunction);

		function myFunction(value, index, array) { // can also just be value by itself
		  return value * 2;
		}
	filter() creates a new array with array elements that passes a test
		var numbers = [45, 4, 9, 16, 25];
		var over18 = numbers.filter(myFunction);

		function myFunction(value, index, array) {
		  return value > 18;
		}
	reduce() runs a function to produce a single value, from left to right in array
	reduceRight() same from right to left
		they do not reduce the original array
		var numbers1 = [45, 4, 9, 16, 25];
		var sum = numbers1.reduce(myFunction);

		function myFunction(total, value, index, array) {
		  return total + value;
		}
	every() check if all array values pass a test
		var numbers = [45, 4, 9, 16, 25];
		var allOver18 = numbers.every(myFunction);

		function myFunction(value, index, array) {
		  return value > 18;
		}
	some() check if some array values pass a test
		var numbers = [45, 4, 9, 16, 25];
		var someOver18 = numbers.some(myFunction);

		function myFunction(value, index, array) {
		  return value > 18;
		}
	indexOf() searches an array for element value and returns its position
		arr.indexOf("element", startPosition)  //returns -1 if not found
	lastIndexOf() same as indexOf() but returns position of last occurence
	find() returns the value of the first element that passes a test function
	findIndex() returns the idex of the first element that passes a test function
Dates
	JS date object - work with dates
		Default:
			* JS will use browsers time zome
			* JS displays dates in full text string format: Wed Mar 25 2015 00:00:00 GMT+0000
	Create date objects
		new Date() constructor creates date objects
			date objects are static
		4 ways
			new Date()
			new Date(year, month, day, hours, minutes, seconds, milliseconds)
			new Date(milliseconds)
			new Date(dateString)
	new Date() current date and time
	new Date(year, month, ...)  specified date and time
		JS counts months from 0 to 11
	Previous century
		one and two digit years are interpreted as 19xx
			new Date(9, 11, 24); // 1909
			new Date(26, 11, 24); // 1926
	new Date(dateString) creates a new date object from a date string
	JS stores dates as milliseconds since Jan 01, 1970 00:00:00 UTC
		1970 = zero time(milisec), 2020 = about 1586626032308 miliseconds past 1970
	new Date(milliseconds) creates new date odbject as zero time plus milliseconds
		new Date(0);  // 01 Jan 1970
		new Date(100000000000); //03 March 1973 as 100000000000 + 01 Jan 1970 = 03 March 1973
		new Date(86400000);  // 02 Jan 1970   86400000 millisec = 1 day
	Date methods
		date methods allow operations on date objects /// date objects can be manipulated with methods
		when displaying a date object in HTML, its automatically converted to strig with the toString() method
		toUTCString() converts date to UTC string (standard date display)
		toDateString() converts a date to a more readable format
Date formats
	JS date input - 3 main JS date input formats
	ISO Date - "2020-03-25" (international standard)
	Short Date "03/25/2020"
	Long Date - "Mar 25 2020" or "25 Mar 2020"
	ISO dates
		JS preferred date format is ISO (YYYY-MM-DD)
			new Date("2015-03-25"); // (YYYY-MM-DD)
			new Date("2015-03"); // (YYYY-MM) allowed
			new Date("2015"); // (YYYY) allowed
	ISO date-time - ISO dates can be written with hrs, mins, and secs (YYYY-MM-DDTHH:MM:SSZ)
		new Date("2015-03-25T12:00:00Z");
			date and time is seperated with "T"
			UTC time is defined with "Z"
				Modify time relative to UTC without "Z", but with +HH:MM or -HH:MM
		UTC = GMT
	Time zones
		getting/setting date without specifying timezone, JS will use the browsers time zone
	Warining:
		* missing zeros like "2020-3-45" may produce error
		* behaviour of "YYYY/MM/DD" is undefined, some browsers guess and some return NaN
		* behaviour of "DD-MM-YYYY" is undefined, some browsers guess and some return NaN
	Long dates - "MMM DD YYYY" or "DD MMM YYYY" or month written fully
	Date input - Parsing dates
		Date.parse() returns milliseconds between Jan 1 1970
			valid date string can use this method to convert it to millisecs
		millisecs can convert it to a date object
			let msec = Date.parse("March 21, 2012");
			let d = new Date(msec);
JS date method
	getTime() returns number of millisecs since Jan 1 1970
	getFullYear() returns year as (yyyy)
	getMonth() returns month as number 0-11
	getDate() returns day as number 1-31
	getHours() returns hour 0-23
	getMinutes() returns minute 0-59
	getSeconds() returns second 0-59
	getMilliSeconds() returns millisec 0-999
	getDay() returns weekday as number 0-6
	Date.now() returns time
	in JS first day of week = 0(sunday)
		can use array to get day as a name instead of number
			var d = new Date();
			var days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
			document.getElementById("demo").innerHTML = days[d.getDay()];
	UTC methods
	All are same as date methods but return UTC date
		getUTCDate() 	Same as getDate(), but returns the UTC date
		getUTCDay() 	Same as getDay(), but returns the UTC day
		getUTCFullYear() 	Same as getFullYear(), but returns the UTC year
		getUTCHours() 	Same as getHours(), but returns the UTC hour
		getUTCMilliseconds() 	Same as getMilliseconds(), but returns the UTC milliseconds
		getUTCMinutes() 	Same as getMinutes(), but returns the UTC minutes
		getUTCMonth() 	Same as getMonth(), but returns the UTC month
		getUTCSeconds( )Same as getSeconds(), but returns the UTC seconds
JS set date methods
	setDate() 	Set the day as a number (1-31)
	setFullYear() 	Set the year (optionally month and day)
	setHours() 	Set the hour (0-23)
	setMilliseconds() 	Set the milliseconds (0-999)
	setMinutes() 	Set the minutes (0-59)
	setMonth() 	Set the month (0-11)
	setSeconds() 	Set the seconds (0-59)
	setTime() 	Set the time (milliseconds since January 1, 1970)
Math object
	JS math object allows you to perform mathemeatical tasks on numbers
	Math.round(x) returns value rounded do nearest int
	Math.pow(x, y) returns value of x to power of y
	Math.sqrt(x) returns square root
	Math.abs(x) returns absolute (positive) value of x
	Math.ceil(x) returns value of x rounded up to nearest int
	Math.floor(x) returns value of x rounded down to nearest int
	Math.sin(x) returns sine (value between -1 and 1) of the angle x (given in radians)
	Math.cos(x) returns cosine (value between -1 and 1) of the angle x (given in radians)
		If you want to use degrees instead of radians, you have to convert degrees to radians:
		Angle in radians = Angle in degrees x PI / 180.
	Math.min() returns lowest value in list of arguments
	Math.max() returns highest value in a list of arguments
	Math.random() returns random number between 0 (inclusive), and 1 (exclusive):
	Math properties (constants)
		JS provides 8 mathematical constants that can be accessed with the math object
		Math.E        // returns Euler's number
		Math.PI       // returns PI
		Math.SQRT2    // returns the square root of 2
		Math.SQRT1_2  // returns the square root of 1/2
		Math.LN2      // returns the natural logarithm of 2
		Math.LN10     // returns the natural logarithm of 10
		Math.LOG2E    // returns base 2 logarithm of E
		Math.LOG10E   // returns base 10 logarithm of E
	Math constructor
		unlike other global objects, the math object has no constructor
		all methods and properties(constants) can be used without creating a math object first
		mathe objec methods
		abs(x) 	Returns the absolute value of x
		acos(x) 	Returns the arccosine of x, in radians
		asin(x) 	Returns the arcsine of x, in radians
		atan(x) 	Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians
		atan2(y, x) 	Returns the arctangent of the quotient of its arguments
		ceil(x) 	Returns the value of x rounded up to its nearest integer
		cos(x) 	Returns the cosine of x (x is in radians)
		exp(x) 	Returns the value of Ex
		floor(x) 	Returns the value of x rounded down to its nearest integer
		log(x) 	Returns the natural logarithm (base E) of x
		max(x, y, z, ..., n) 	Returns the number with the highest value
		min(x, y, z, ..., n) 	Returns the number with the lowest value
		pow(x, y) 	Returns the value of x to the power of y
		random() 	Returns a random number between 0 and 1
		round(x) 	Returns the value of x rounded to its nearest integer
		sin(x) 	Returns the sine of x (x is in radians)
		sqrt(x) 	Returns the square root of x
		tan(x) 	Returns the tangent of an angle
Random
	Math.random() returns a random number between 0(exclusive) and 1(inclusive)
		always returns a number lower than 1
	Random integers
		Math.random() used with Math.floor() can be used to return random integers
			Math.floor(Math.random() * 10);     // returns a random integer from 0 to 9
			Math.floor(Math.random() * 101);     // returns a random integer from 0 to 100
			Math.floor(Math.random() * 10) + 1;  // returns a random integer from 1 to 10
	Proper Random function
		the random functon as shown above in random integers always returns a number between min(included) and max(excluded)
			function getRndInteger(min, max) {
			  return Math.floor(Math.random() * (max - min) ) + min;
			}
		function with both min and max included
		function getRndInteger(min, max) {
			return Math.floor(Math.random() * (max - min + 1) ) + min;
			}
booleans
	Boolean(expression) function returns true if expression is true
 	comaparision and condition
		== equivalent
		> greater than
		< less than
	empty strings are false, non empty strings are true
	any expression is true except zero
		Boolean(0) // false
		Boolean("") // false
		Boolean(undefined) // false
		Boolean(null) // false
		Boolean(false) // false
		Boolean(NaN) // false
		Boolean(0) // false
	booleans can be Objects
		normally Js booleans are primateve balues created from literals
			var x = false; // typeof x returns boolean
		But booleans can also be defined as objects with the keyword new:
			var y = new Boolean(false);// typeof y returns object
		do not create boolean objects, they slow down execution speed and coplicate code
comparison and logical operators
	used to test for 'true' or 'false'
	comparison operators - used in conditional statements to compare balues
		== === != !== > < >= <=
	logical operators - used to determine the logic between variable and balues
		&& || !
	conditional (ternary operator)
		JS contains a conditional operator that assigns a value to a variable based on some condition
			variablename = (condition) ? value1:value2
		comparing different datatypes
			when comparing a string with a number JS will convert the string to a number, an empty = 0, non-numeric string = NaN = false
			2 < 12 	true
			2 < "12" 	true
			2 < "John" 	false
			2 > "John" 	false
			2 == "John" 	false
			comparing string with string is done alphabetically
				"2" < "12" 	false
				"2" > "12" 	true
				"2" == "12" 	false
					to secure a proper result vars shold be conbverted to the proper type before comaparision
					age = Number(age);
					if (isNaN(age)) {
					  voteable = "Input is not a number";
					} else {
					  voteable = (age < 18) ? "Too young" : "Old enough";
					}
conditions
	 conditional statements - perfom different actons for different decisions
	Use if to specify a block of code to be executed, if a specified condition is true
	Use else to specify a block of code to be executed, if the same condition is false
	Use else if to specify a new condition to test, if the first condition is false
	Use switch to specify many alternative blocks of code to be executed
	if (condtion) {}
	elseif (condition) {}
	else (condition) {}

switch statement - select one of many code blocks to be executed
	swich () {
	  case 1:
	  break;
	  default
	}
    The switch expression is evaluated once.
    The value of the expression is compared with the values of each case.
    If there is a match, the associated block of code is executed.
	break beyword breaks out of switch bloxk, stop the execution within the block, no need to break last case as defualt
	break stops execution of next case, for cases you want same code ommit the break to execute to next case
	default specifies code to run if no match
	details
		if multiple case values match then the first case is selceted
		if no matching cases, default selected
		if no default the progran continues after switch statement
	strict comparison - switch cases use strict comparison ===
		the values/operands must be of the same type
loops
	JS supports different types of loops:
    for - loops through a block of code a number of times
    for/in - loops through the properties of an object
    for/of - loops through the values of an iterable object
    while - loops through a block of code while a specified condition is true
    do/while - also loops through a block of code while a specified condition is true
	For loop
		for (statement 1; statement 2; statement 3) {
		// code block to be executed
		}
		Statement 1 is executed (one time) before the execution of the code block.
		Statement 2 defines the condition for executing the code block.
		Statement 3 is executed (every time) after the code block has been executed.
		for (i = 0; i < 5; i++) {
		  text += "The number is " + i + "<br>";
		}
		Statement 1 sets a variable before the loop starts (var i = 0).
		Statement 2 defines the condition for the loop to run (i must be less than 5).
		Statement 3 increases a value (i++) each time the code block in the loop has been executed.
		Statement 1
			normally used to initialize the var used in loop
			not always case, statement 1 is optional
				var i = 2;
				var len = cars.length;
				var text = "";
				for (; i < len; i++) {
				text += cars[i] + "<br>";
				}
			many values can be intiated in statement 1 seperated by comma
				for (i = 0, len = cars.length, text = ""; i < len; i++) {
				  text += cars[i] + "<br>";
				}
		statment 2
			normally used to evaluate the condition of the initial variables
			not always the case, statement 2 is optional
			if statment 2 returns true the loop will start over again, if false the loop ends
			use break if ommitting statment 2, or loop will never end
		statement 3
			do anything to value of the initail var
			statement 3 is optional, if ommited you can increment values within the loop
			statement 3 can do positive/negative incerement or anythign else
		for/in - loops through the properties of an object:
			var person = {fname:"John", lname:"Doe", age:25};
			var text = "";
			var x;
			for (x in person) {
			  text += person[x];
			}
		for/of - loops through the values of an iterable objects
			loop over data structors that are iterable like arrays strings maps nodelists and more
			for (variable of iterable) {
			  // code block to be executed
			}
			variable - For every iteration the value of the next property is assigned to the variable. Variable can be declared with const, let, or var.
			iterable - An object that has iterable properties.
			looping an array
				var cars = ['BMW', 'Volvo', 'Mini'];
				var x;
				for (x of cars) {
				  document.write(x + "<br >");
				}
			looping over a sting
				var txt = 'JavaScript';
				var x;

				for (x of txt) {
				  document.write(x + "<br >");
				}
While loops
	loops through code as long as condition is true
	the loop will never end unless the condition becomes false, so make sure increment/decrement or other happens.
	while (condition) {
	// code block to be executed
	}
	do while loops
		will execute code onece before checking if the condition is true, then will repeat as long as condition is true
		do {
		// code block to be executed
		}
		while (condition);
	comparing for and while
		the while loop is the same as the for loop with statemnt 1 and statement 3 omitted
Break and continue
	break statement "jumps out" of a loop.
	continue statement "jumps over" one iteration in the loop
	//break e.g.
	for (i = 0; i < 10; i++) {
		if (i === 3) { break; }
		text += "The number is " + i + "<br>";
	}
	// continue .g.
		for (i = 0; i < 10; i++) {
			if (i === 3) { continue; }
			text += "The number is " + i + "<br>";
		}
	JS lables
		label JS statements by preceding the statemnt iwth a lable name and colon
			```
			label:
			statements
			```
		break and continue statements are the only JS statments that can jump out a code block
		break labelname;
		continue labelname;
		continue statement with/without label rference only skips one loop interation
		break statment with label reference only jump out of a for/switch statment
			but with label reference the break statement can be used to jump out of any code block
			var cars = ["BMW", "Volvo", "Saab", "Ford"];
			list: {
			text += cars[0] + "<br>";
			text += cars[1] + "<br>";
			break list;
			text += cars[2] + "<br>";
			text += cars[3] + "<br>";
			}
		A code block is between '{' and '}'
JS type conversion
	Number() converts to number
	String() converts to string
	Boolean() converts to boolean
	JS Data types
	in JS 5 data types that can contain values
	string
	number
	boolean
	object
	function
 	6 types of objects:
	Object
	Date
	Array
	String
	Number
	Boolean
	And 2 data types that cannot contain values:
	null
	undefined
	typeof "John"                 // Returns "string"
	typeof 3.14                   // Returns "number"
	typeof NaN                    // Returns "number"
	typeof false                  // Returns "boolean"
	typeof [1,2,3,4]              // Returns "object"
	typeof {name:'John', age:34}  // Returns "object"
	typeof new Date()             // Returns "object"
	typeof function () {}         // Returns "function"
	typeof myCar                  // Returns "undefined" *
	typeof null                   // Returns "object"
		NaN is numbers
		array is object
		date is objects
		null is object
		undefined and var not assigned value is undefined
		typeof cannot tell you if the data type is date of array as returns obleict
	the data type of typeof
		typeof operator is not a variable, its an operator, operators are not data Types
		but typeof operator always returns a string (containg the type of the operand)
	constructor property
		constructor returns the constructor functoin for all JS Variables
		"John".constructor                // Returns function String()  {[native code]}
		(3.14).constructor                // Returns function Number()  {[native code]}
		false.constructor                 // Returns function Boolean() {[native code]}
		[1,2,3,4].constructor             // Returns function Array()   {[native code]}
		{name:'John',age:34}.constructor  // Returns function Object()  {[native code]}
		new Date().constructor            // Returns function Date()    {[native code]}
		function () {}.constructor        // Returns function Function(){[native code]}
		use constructor property to find out if oblect is an array
			function isArray(myArray) {
				return myArray.constructor.toString().indexOf("Array") > -1;
			}
			or simpler cbeeck if the object is an array function
				function isArray(myArray) {
					return myArray.constructor === Array;
				}
		use constructor property to find out if oblect is an array
			function isDate(myDate) {
			  return myDate.constructor.toString().indexOf("Date") > -1;
			}
			or simpler cbeeck if the object is an array function
				function isDate(myDate) {
					return myDate.constructor === Date;
				}
JS type conversion
	JS vars can be converted to a new var and another data types:
		* use of JS function
		* automatically by JS
	converting numbers to strings
		global method String() converts to string
			can be used on any type onf numbers, literals, vars or expressions
			String(x)         // returns a string from a number variable x
			String(123)       // returns a string from a number literal 123
			String(100 + 23)  // returns a string from a number from an expression
		the number method toString() does the same
			x.toString()
			(123).toString()
			(100 + 23).toString()
			toExponential() 	Returns a string, with a number rounded and written using exponential notation.
			toFixed() 	Returns a string, with a number rounded and written with a specified number of decimals.
			toPrecision() 	Returns a string, with a number written with a specified length
	convreting booleans to Strings
		String() convert booleans to Strings
		String(false)      // returns "false"
		String(true)       // returns "true"
		toString() does Same
			false.toString()   // returns "false"
			true.toString()    // returns "true"
		dates to string are the same: String() toString()
		other methods include all get methods for dates like getDate() and getMinutes()
	Converting strings to numbers
		number() can convert strings to numbers
			empty strings return 0
			number strings convert to numbers
			other returns NaN
		other methods include parseFloat() and parseInt()
	Unary + operator - used to convert a cariable to a number
		var y = "5";      // y is a string
		var x = + y;      // x is a number
		if var cannot be converted the value = NaN
			var y = "John";   // y is a string
			var x = + y;      // x is a number (NaN)
	convreting booleans to numbers
		Number() van conbert booleans to numbers
		Number(false)     // returns 0
		Number(true)      // returns 1
	converting dates to numbers
		Number() can convert dates to numbers
			d = new Date();
			Number(d)          // returns 1404568027739
		getTime() does Same
	Automatic type conversion
		JS will try to convert values:
		5 + null    // returns 5         because null is converted to 0
		"5" + null  // returns "5null"   because null is converted to "null"
		"5" + 2     // returns "52"      because 2 is converted to "2"
		"5" - 2     // returns 3         because "5" is converted to 5
		"5" * "2"   // returns 10        because "5" and "2" are converted to 5 and 2
	Automatic string conversion
		JS automatically calls the toString() function when you outpup an object or var
			document.getElementById("demo").innerHTML = myVar;
			// if myVar = {name:"Fjohn"}  // toString converts to "[object Object]"
			// if myVar = [1,2,3,4]       // toString converts to "1,2,3,4"
			// if myVar = new Date()      // toString converts to "Fri Jul 18 2014 09:08:55 GMT+0200"
			// Numbers and booleans are also converted, but this is not very visible:
			// if myVar = 123             // toString converts to "123"
			// if myVar = true            // toString converts to "true"
			// if myVar = false           // toString converts to "false"
JS Bitwise operations
	& 	AND 											Sets each bit to 1 if both bits are 1
	| 	OR 												Sets each bit to 1 if one of two bits is 1
	^ 	XOR 											Sets each bit to 1 if only one of two bits is 1
	~ 	NOT											 	Inverts all the bits
	<< 	Zero fill left shift		 	Shifts left by pushing zeros in from the right and let the leftmost bits fall off
	>> 	Signed right shift 				Shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off
	>>> 	Zero fill right shift 	Shifts right by pushing zeros in from the left, and let the rightmost bits fall off
	JS use 32 bitwise operands
		JS stores numbers as 64 bit floating toinp numbers
		before a bitwise operation is performed JS converts numbers to 32 bit signed integers
		after a bitwise operatino is performed the result is converted back to 64 bits JS numbers
	Bitwise AND
		bitwise AND returns 1 if both bits are 1
			e.g.  one bit
							operation 		result
				  		0 & 0					0
							0 & 1					0
							1 & 0					0
							1 & 1					1
						4 bits
							1111 & 0000		0000
							1111 & 0001		0001
							1111 & 0010		0010
							1111 & 0100		0100
	bitwise OR
		bitwise OR returns 1 if one of the bits are 1
		e.g.  one bit
						operation 		result
						0 | 0					0
						0 | 1					1
						1 | 0					1
						1 | 1					1
					4 bits
					1111 | 0000			1111
					1111 | 0001			1111
					1111 | 0010			1111
					1111 | 0100			1111
	bitwise XOR
		bitwise XOR returns 1 if the bits are different
		e.g.  one bit
						operation 		result
						0 ^ 0					0
						0 ^ 1					1
						1 ^ 0					1
						1 ^ 1					0
					4 bits
					1111 ^ 0000			1111
					1111 ^ 0001			1110
					1111 ^ 0010			1101
					1111 ^ 0100			1011
	bitwise AND (&)
		returns 1 oniy if both bits are 1
	bitwise OR (|)
		returns 1 if one of the bits are 1
	bitwise XOR (^)
		returns 1 if bits are different
	bitwise not (~)
	(zero fill) bitwise left shift (<<)
		This is a zero fill left shift. One or more zero bits are pushed in from the right, and the leftmost bits fall off
	(sign preserving) bitwise right shift(>>)
		This is a sign preserving right shift. Copies of the leftmost bit are pushed in from the left, and the rightmost bits fall off
	(zero fill) bitwise right shift (>>>)
		This is a zero fill right shift. One or more zero bits are pushed in from the left, and the rightmost bits fall off
	Binary numbers
		stored in two's complement formats
		therefore negative numbes is the bitwise NOT of the number plus 1
			binary represtnation 								decimal
			00000000000000000000000000000101		5
			11111111111111111111111111111011		-5
			00000000000000000000000000000110		6
			11111111111111111111111111111010		-6
			00000000000000000000000000101000		40
			11111111111111111111111111011000		-40
	converting decimal to binary
	function dec2bin(dec){
		return (dec >>> 0).toString(2);
	}
	converting binary to decimal
	function bin2dec(bin){
	  return parseInt(bin, 2).toString(10);
	}
Regular expressions
	sequence of chars that forms a search pattern
	the search pattern can be used for text search and text replace operations
	search pattern can be used to describle what seaching for
	regular expression can be single char or a more complicated pattern
	syn: /pattern/modifiers;
		let patt = /hello/i;
		/hello/i  is a regular expression.
		hello  is a pattern (to be used in a search).
		i  is a modifier (modifies the search to be case-insensitive)..
	using string methods
		inJS regular expressions normally used with two strign methods search() and replace()
		search() uses an expsression to search for a match and returns the position of the matches
		replace() returns a modified string where the pattern is replaced
	using string search() with a string
		var str = "Visit me!";
		var n = str.search("me");
	using string search() with a regular expression
		var str = "Visit me";
		var n = str.search(/me/i);
	using string replace() with a string
		var str = "Visit Microsoft!";
		var res = str.replace("Microsoft", "me");
	using string replace() with a regular expression
		var str = "Visit Microsoft!";
		var res = str.replace(/microsoft/i, "me");
	Regular expression arguments (instead of string arguments) can be used in the methods above.
	Regular expressions can make your search much more powerful (case insensitive for example).
	Regular expression modifiers
	i case insensitive, g tloabal match m perform multiline matching
	Regular expression patterns
	[abc] 	Find any of the characters between the brackets
	[0-9] 	Find any of the digits between the brackets
	(x|y) 	Find any of the alternatives separated with |

	Metacharacters are characters with a special meaning:
	Metacharacter 	Description
	\d 	Find a digit
	\s 	Find a whitespace character
	\b 	Find a match at the beginning of a word like this: \bWORD, or at the end of a word like this: WORD\b

	\uxxxx 	Find the Unicode character specified by the hexadecimal number xxxx

	Quantifiers define quantities:
	Quantifier 	Description
	n+ 	Matches any string that contains at least one n
	n* 	Matches any string that contains zero or more occurrences of n
	n? 	Matches any string that contains zero or one occurrences of n
	using the RegExp object
		in Js the regExp object is a regular expression object with predefined properties and methods
	using test()
		test() method is a RegExp expression method
			searches for a string for a pattern and returns true or false depending on result
			// search for 'e'
			var patt = /e/;
			patt.test("The best things in life are free!"); // since e is there the output is true
				can be shortend to one line:
					/e/.test("The best things in life are free!");
	using exec()
	 exec() is a RegExp expression method
	 	It searches a string for a specified pattern, and returns the found text as an object.
		if no match it returns null
			// search for 'e'
			/e/.exec("The best things in life are free!");
Errors - throw and try to catch
	try statement lets you test a block of code for errors.
	catch statement lets you handle the error.
	throw statement lets you create custom errors.
	finally statement lets you execute code, after try and catch, regardless of the result
	errors can happen
		when executing JS, errors can occur
		errors can be made by programmer, due to wrong input and other unforseeable things
	JS try and catch
		The try statement allows you to define a block of code to be tested for errors while it is being executed.
		The catch statement allows you to define a block of code to be executed, if an error occurs in the try block.
		The JavaScript statements try and catch come in pairs:
			try {
				Block of code to try
			}
			catch(err) {
				Block of code to handle errors
			}
	JS throws Errors
		when errors occur JS normally stops and generated an error message
		this is known as JS /bthrowing an exception/b
			JS will create a error object with two properties name and message
	Throw statements
		throw - create custom Errors
			technically you can /bthrow an exception/b
				the exception can be a JS 'string', 'Number', 'Boolean' or 'Object':
					throw "Too big";    // throw a text
					throw 500;          // throw a number
		if use throw' with try' and c'atch'  you can control program flow and generate custom error messages
	input validation example
		This example examines input. If the value is wrong, an exception (err) is thrown.
		The exception (err) is caught by the catch statement and a custom error message is displayed:
			<body>
				<p>Please input a number between 5 and 10:</p>
				<input id="demo" type="text">
				<button type="button" onclick="myFunction()">Test Input</button>
				<p id="p01"></p>
				<script>
				function myFunction() {
				  var message, x;
				  message = document.getElementById("p01");
				  message.innerHTML = "";
				  x = document.getElementById("demo").value;
				  try {
				    if(x == "") throw "empty";
				    if(isNaN(x)) throw "not a number";
				    x = Number(x);
				    if(x < 5) throw "too low";
				    if(x > 10) throw "too high";
				  }
				  catch(err) {
				    message.innerHTML = "Input is " + err;
				  }
				}
				</script>
			</body>
	HTML validation
		code above is an example
		modern browsers oftenlly use a combination of JS built-in HTML validation, using predefined validation rules defined in HTML attriblutes:
			<input id="demo" type="number" min="5" max="10" step="1">
	the finally statement
		finally statement lets you execute code, after try and catch, regardless of the result
			syn:
				try {
				  Block of code to try
				}
				catch(err) {
				  Block of code to handle errors
				}
				finally {
				  Block of code to be executed regardless of the try / catch result
				}
			e.g. function myFunction() {
					  var message, x;
					  message = document.getElementById("p01");
					  message.innerHTML = "";
					  x = document.getElementById("demo").value;
					  try {
					    if(x == "") throw "is empty";
					    if(isNaN(x)) throw "is not a number";
					    x = Number(x);
					    if(x > 10) throw "is too high";
					    if(x < 5) throw "is too low";
					  }
					  catch(err) {
					    message.innerHTML = "Error: " + err + ".";
					  }
					  finally {
					    document.getElementById("demo").value = "";
					  }
					}
	error object
		JS has built in error object that probides error information when an error occurs
		the error object probieds two usefl properteis: name and messages
			name sets or returns an error named
			message sets or returns an error message (string)
		error name values - six differnt values retruned by the name property:
			EvalError	An error has occurred in the eval() function
			RangeError	A number "out of range" has occurred
			ReferenceError	An illegal reference has occurred
			SyntaxError	A syntax error has occurred
			TypeError	A type error has occurred
			URIError	An error in encodeURI() has occurred
		EvalError dont use as is not used in newer versions. use SyntaxError instead
			do not use as is old
			use SyntaxError instead
		RangeError is thrown if you use a number that is outside the range of legal values.
			For example: You cannot set the number of significant digits of a number to 500.
			var num = 1;
				try {
				  num.toPrecision(500);   // A number cannot have 500 significant digits
			}
				catch(err) {
				  document.getElementById("demo").innerHTML = err.name;
			}
		ReferenceError is thrown if you use (reference) a variable that has not been declared:
			var x;
			try {
			  x = y + 1;   // y cannot be referenced (used)
			}
			catch(err) {
			  document.getElementById("demo").innerHTML = err.name;
			}
		SyntaxError is thrown if you try to evaluate code with a syntax error.
		 	try {
		  	eval("alert('Hello)");   // Missing ' will produce an error
		 	}
		 	catch(err) {
		  	document.getElementById("demo").innerHTML = err.name;
		 	}
		TypeError is thrown if you use a value that is outside the range of expected types
			var num = 1;
			try {
			  num.toUpperCase();   // You cannot convert a number to upper case
			}
			catch(err) {
			  document.getElementById("demo").innerHTML = err.name;
			}
		URIError (Uniform Resource Identifier) is thrown if you use illegal characters in a URI function:
			try {
			  decodeURI("%%%");   // You cannot URI decode percent signs
			}
			catch(err) {
			  document.getElementById("demo").innerHTML = err.name;
			}
Scope - 2 types local and global
	function scope, each function creates a new Scope
	scope determines accessiblity of Variables
	local Scope
		defined within function beconme local to function
	global Scope
		decalred outside function is glocal and all scripts and functions on a web page can access it
	Variables
		objects and functions are also variables
		scope can determine the accessibility of these
	automatically gloval
		assingnineg a value to var that isnt becalred it will automatically be blobal
		myFunction();
		// code here can use carName
		function myFunction() {
			carName = "Volvo";
		}
	strict mode
		all modern browsers support JS in strict mode
		undeclared vars are not automatically global in strict mode
	global vars in html
		With JavaScript, the global scope is the complete JavaScript environment.
		In HTML, the global scope is the window object. All global variables belong to the window object
			var carName = "Volvo";
			// code here can use window.carName
	Warining
		dont create global vars unless intended
		global vars or functions can overite window vars or functions
		 any function including the window oblect can oberwrite your global cars and functions
	variable lifetime
		start - when var decalared
		end - local vars deleted when function is completed
		end - global vars deleted when you close the browser Window
	function arguments - (parametres) work as local vars within functins
JS hoisting - best practice is to declare and initialize vars at top of scopes and don't hoist
JS hoisting - hosting is JS's default behavior of moving declarations to the top
	JS declarations are hoised
		variable can be declared after it has been used aka variable can be used before it has been decalared
			x = 5; // Assign 5 to x
			elem = document.getElementById("demo"); // Find an element
			elem.innerHTML = x;                     // Display x in the element
			var x; // Declare x
		hoisting is JS default behaviour of moving all adeclarations to the top of the current scope(script of current function)
	let and const keywords
		vars and constants decalred with let or const are not hoisted
	JS initilixations are not hoisted
		JS only hoists declarations not initilizations
			var x = 5; // Initialize x
			elem = document.getElementById("demo"); // Find an element
			elem.innerHTML = x + " " + y;           // Display x and y is undefined
			var y = 7; // Initialize y
		y is undefiend as only the declaration not the initilization =7 is hoisted
		because y is declared before used y is undefined
		this is the same as
			var x = 5; // Initialize x
			var y;     // Declare y
			elem = document.getElementById("demo"); // Find an element
			elem.innerHTML = x + " " + y;           // Display x and y
			y = 7;    // Assign 7 to y
		hoisting is not used often or at all as can cuase errors
			this is due to debs not understanding, therefore causing bugs
			therefore always declare vars at beginning of scopes
Strict mode
	'"use strict";' Defines that JavaScript code should be executed in "strict mode"
	The "use strict" Directive
		it is not a statement but a literal expression
		indicated that code should be executed in strict mode
		strict mode - cannot use undeclared variables
	helps write cleaner code by prevweneting undeclared variables
	declaring strict mode
		strict mode decalred by adding "use strict"; to the beginning of a script or a function.
		Declared at the beginning of a script, it has global scope, (so all code in the script will execute in stxit mode)
		Declared inside a function, it has local scope (only the code inside the function is in strict mode):
	why strict mode?
		esier to write secure JS
		changes previous bad syntax into real Errors
		In strict mode, any assignment to a non-writable property, a getter-only property, a non-existing property, a non-existing variable, or a non-existing object, will throw an error.
	strict mode rules / not allowed in strict mode
		using variables without declaring
		deleting an var/obj is not allowed
		deleting functions are not allowed
		duplicating a parameter name is not allowed
		octal numeral literals are not allowed
		octal escape chars are not allowed
		writing to a read only property or get only property is not allowed
		deleting an undeletable property is not allowed
		'eval' cannot be used as variable name
		'arguments' cannot be used as var name
		'with' statment is not allowed
		eval() is not allowed to create vars in the scope from which it was called for security reasons
		'this' keyword in functions behaves differently in strict mode.
		'this'  keyword refers to the object that called the function.
		If the object is not specified, functions in strict mode will return undefined and functions in normal mode will return the global object (window):
	Future proof
		keywords reserved for suture JS versions can not be used as var name in strict mode:
		  * implements
		  * interface
		  * let
		  * package
		  * private
		  * protected
		  * public
		  * static
		  * yield
this keyword
	this refers to the object it belongs to
	It has different values depending on where it is used:
    In a method, this refers to the owner object.
    Alone, this refers to the global object.
    In a function, this refers to the global object.
    In a function, in strict mode, this is undefined.
    In an event, this refers to the element that received the event.
    Methods like call(), and apply() can refer this to any object.
let
	provides block scope variables (and constants) in JavaScript.
